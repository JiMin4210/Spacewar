0. 자바 자체는 jvm에서 돌아가고 다른 메모리영역으로 빠져나갈수는 없다.

1. mknod 명령 찾아보기
  -> dev 만드는 방법이다.
  -> 단순 int mknod라는 함수 라이브러리로
  -> insmod로 디바이스를 커널에 등록한 다음 사용함 즉 커널에 access하려면 major번호 필요해서 그 번호를 등록하는 것이다.

2. make파일 clean의 이유?

3. MODULE_LICENSE("GPL");
   MODULE_AUTHOR("Huins");
  -> 이 dev 모듈이 오픈소스 라이센스를 따른다고 커널에게 알려주는 역할, 사용하지 않는다면 경고메시지가 뜸 (없어도 되긴함)

4. printk()는 커널에 대한 것이고 printf()는 사용자 공간에 대한 것입니다. 
  printk()에 의해 작성된 라인은 dmesg 명령을 통해 표시될 수 있습니다. 
  인쇄해야 하는 메시지가 얼마나 중요한지에 따라  (0이 제일 높은 순위)
  include/linux/kern_levels.h에 정의된 8개의 로그 수준 메시지와 의미를 선택할 수 있습니다.
  레벨은 콘솔에서 사용자에게 표시되어야 하는 것과 표시되지 않아야 하는 것을 결정하는 데 유용합니다.

  모든 콘솔에는 콘솔 로그 수준이라는 로그 수준이 있으며 
  콘솔 로그 수준보다 낮은 로그 수준 번호를 가진 메시지는 콘솔에 표시되고 
  로그 수준 번호가 콘솔 로그 수준보다 높거나 같은 기타 메시지는 기록됩니다. 
  명령을 사용하여 조사할 수 있는 커널 로그에서 dmesg.

  콘솔 로그 레벨은 /proc/sys/kernel/printk.conf 파일에서 찾을 수 있습니다.
  cat /proc/sys/kernel/printk
  4 4 1 7
  출력의 첫 번째 숫자는 콘솔 로그 수준, 두 번째 숫자는 기본 로그 수준, 
  세 번째 숫자는 최소 로그 수준, 네 번째 숫자는 최대 로그 수준입니다.

  로그 수준 4는 KERN_WARNING에 해당합니다. 
  따라서 로그 수준이 3,2,1 및 0인 모든 메시지가 화면에 표시되고 기록되며 
  로그 수준이 4,5,6,7인 메시지만 dmesg에 기록되고 다음을 사용하여 볼 수 있습니다 . (dmesg 명령어 치면 디버그창 뜬다) 

  콘솔 로그 수준은 proc 항목에 작성하여 변경할 수 있습니다. -> 이걸 변경함으로써 콘솔 디버그 기준값을 낮춘다.

#define KERN_EMERG "<0>" /* system is unusable*/
#define KERN_ALERT "<1>" /* action must be taken immediately*/
#define KERN_CRIT "<2>" /* critical conditions*/
#define KERN_ERR "<3>" /* error conditions*/
#define KERN_WARNING "<4>" /* warning conditions*/
#define KERN_NOTICE "<5>" /* normal but significant condition*/
#define KERN_INFO "<6>" /* informational*/
#define KERN_DEBUG "<7>" /* debug-level messages*/

알리다   KERN_ALERT   즉각적인 조치가 필요합니다 -> 이거라서 바로 커널에 표시되는듯
원래는 커널에 바로 표시되지 않게 만들어놨다했음

5. 기존 연결된 디바이스는
  -> 0800_0000 ~ 0FFFF_FFFF -> EIM - (NOR/SRAM)에 연결 돼 있다.
  -> 교수님은 0040_0000~007F_FFFF Reserved에다가 디바이스 추가하라 하심

6. ioremap(물리적 I/O주소, I/O영역 size)
  -> ioremap은 장치에 있는 I/O 메모리를 가상메모리 공간으로 mapping을 시켜주는 일을 한다.
      (즉 IO 주소영역은 별개로 있다는 뜻 같다)
  -> 성공시 반환값은 할당된 가상 선두 주소가 된다.
  -> device를 제어할 때는 크게 네가지 자원을 이용합니다. 
  ->I/O memory, I/O port, interrupt, DMA가 그것이죠. 
     그중에서 I/O memory를 사용하려면 해당 메모리를 접근할 수 있어야겠죠. 
     그러려면 해당 I/O 메모리를 메모리 공간에 mapping을 시켜주어야 합니다. 
     ioremap은 장치에 있는 I/O 메모리를 가상메모리 공간으로 mapping을 시켜주는 일을 합니다
  
  -> 디바이스의 물리메모리는 직접 접근이 불가능합니다. (꼭 디바이스 뿐 아니라 다른 프로세스의 물리메모리는 직접접근 불가-커널이 막음)
      (유저영역-JNI c언어, 커널영역-dev driver 둘다 실제 디바이스 물리주소를 직접제어 불가능)
     왜냐면 가상메모리의 페이지 테이블 관리 기법 때문이죠. 
     그래서 ioremap 을 호출해서 실제 메모리를 가상메모리로 할당받아서 
     그 메모리 베이스를 기반으로 inb 나 outb등을 사용하는 것입니다. 
  -> 가상메모리 주소에 쓰게되면 피지컬 메모리에 써지는것이다. 
      (즉 원래 ram에는 io가 연결이 안 돼있지만 매핑을 통해 ram에 I/O메모리와 연결된 가상메모리를 할당받아서 간접적으로 접근하는것)

  -> 본래의 커널 주소공간에는 I/O주소가 없지만 ioremap을 통해 커널의 주소공간으로 넣어줘야 I/O 영역을 사용가능하다.
  -> 이러한 가상메모리를 이용해 I/O주소에 접근하는것을 메모리 맵드 I/O라고하는것같다.
      (뭐 이건 아닌거같고 I/O주소 자체를 일반 메모리와 하나로보는거 자체가 메모리 맵드 I/O이다)
      (이렇게 가상주소로 연결하는건 진짜 물리적 주소공간을 우리가 직접 접근은 안되기에 연결시켜주는것 같다)
  -> ioremap함수는 실제적으로 device early I/O memory mapping이라고 한다.

  -> 다른 프로세스의 메모리 공간 접근 ★★★★★★★★★★★★★
      프로세스가 시스템 호출을 통해 커널 모드로 진입하면 
      프로세스 메모리 공간은 커널의 메모리 공간으로 바뀐다. 
      커널 모드 상태의 프로세스는 수퍼바이저 권한을 갖기 때문에 시스템 내의 모든 메모리 공간에 접근할 수 있다. 
      그래서 이 경우에는 다른 프로세스의 메모리 공간에 접근할 수 있는데, 이때 직접 접근은 안 되고, 
      VM에서 제공하는 특정 함수를 통해 접근할 수 있다.  ioremap() 등등
 
      물리 주소 공간을 커널 주소 공간으로 매핑
      Memory Mapped I/O 방식의 물리적 주소 공간을 커널에서 사용 가능한 가상 주소로 매핑하거나 
      해제할 때는 다음과 같은 함수 사용한다. ioremap()

      I/O 물리 주소와 가상 주소간의 변환 함수 ioremap() 설명
      리눅스 커널은 부팅 단계에서 시스템을 제어하기 위해 사용하는 시스템의 모든 I/O 제어 물리 주소나 
      램 영역의 물리 주소를 MMU 테이블로 미리 작성한다. 
      이렇게 부팅 단계에서 고정되어 할당된 메모리 주소 영역을 예약 영역(reserved area)이라고 한다. 
      예약된 물리 주소 영역은 PAGE_OFFSET 매크로 상수값을 이용해 물리 주소와 가상 주소간에 변환을 한다. 
      상수 연산만으로 물리 주소를 가상 주소로 만들기 위해 사용하는 상수와 매크로는 #include 에 정의된다.



7. application에서 dev 열 때 open함수
  -> 즉 device node를 열 때 발생
  -> inode *inode_p의 경우 MAJOR(inode_p->i_rdev)로 MAJOR 출력 가능하다
  -> JNI c언어에서 open("dev/led",O_RDWR)시의 리턴값은 MAJOR이지 여기 open함수에서 return값은 JNI c언어로 가지는 않는다.
  -> 예상하기론 dev.ko파일의 open 리턴값은 노드 열면서 다른쪽에서 실행되는것 같다.
  -> 예상 경로 -> open(dev) -> 커널에서 device node open -> dev driver 실행 -> open함수 실행 -> 커널에서 JNI c언어로 MAJOR전송
  -> open끝나도 device driver는 메모리에서 돌아갈듯 JNI에서 close시 커널이 드라이버 코드에서 release함수 실행하고 device driver 꺼질듯
  -> 드라이버의 open 함수는 반드시 0을 리턴해야 한다. 다른 값은 에러이다.

8. 외부 staitc 변수 = 다른 파일에서는 사용 불가 (다른데에서 못사용하게하는게 주 목적인듯 - 은닉의 효과)
   내부 static 변수 = 함수 종료되도 그대로 남음 (but 해당 함수에서밖에 못씀 - 은닉의 효과)

9. /work/achro-imx6q/kernel 경로를 가지는 디바이스 드라이버 makefile 인터넷에 찾아보기
  -> 환경을 만들기 위함.

10. copy_from_user(to,from,n) -> write
  -> 사용자 메모리 블록 데이터를 커널 메모리 블록 데이터에 써넣는다.
  -> from이 가리키는 주소의 사용자 메모리 블록 데이터를 to가 가리키는 커널 메모리 블록 데이터에
      바이트 크기 단위인 n만큼 써넣는다.
  -> 반환값은 복사되지 않은 바이트 수를 리턴한다. (정상일 경우 0이 리턴)

11.copy_to_user(to,from,1) -> read
  -> 커널 메모리 from을 사용자 메모리 to에다가 써넣는다
  -> 즉 led로 read한 데이터를 JNI c언어에서 read(buf) 버퍼쪽 즉 gdata에 그 값을 집어넣는 것이다
  -> 커널 메모리는 커널에서 돌아가는 드라이버 내 변수고 사용자 메모리는 JNI c언어 메모리이다.

  -> ★꼭 이렇게 넣어야 하는가? 그냥 strcpy같은걸로 하면 안되나?
  -> xxx_read에 전달된 버퍼의 주소 값은 프로세스의 메모리 공간을 지정하는 주소 값이기 때문에 디바이스 드라이버에서 직접 사용할 수 없다
  -> kernel 영역과 user 영역은 서로 접근하지 못하는 메모리 영역이기 때문에, pointer를 이용하지 못하고, 데이터를 전달하는 함수를 이용
  -> 즉 버퍼를 만들고 그 내용을 복사해야만 하는것이다.
  -> ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★

12. value = _s_value & 0xF;
  -> 0xF를 and연산 하는 이유?

13. LED는 해당 주소값안쪽 8bit 데이터들이 1:1로 LED랑 직접연결 돼 있는듯
  -> 이러한 생각을 한 이유는 어쨋든 주소 내부의 데이터는 저장 돼 있어야하기에 레지스터들로 이루어져있을 것이고 여기에 LED를
      연결해놓으면 이 코드들이 말이 되기 때문이다.

14. LCD같은 계속 정보를 줘야하는것
  -> write함수를 쓸 시 데이터가 레지스터를 통해 목적메모리로 이동 (좀 느림)
  -> mmap을 사용하면 고속으로 하드웨어 목적 주소로 이동 할 수 있다.
     (프레임 버퍼를 만들고 DMA로 처리하게 된다고한다 -> 성능저하없이 구현 가능)

15. inb(), inw(), inl(), insb(), insw(), insl(): 하드웨어에서 데이터를 읽는다.
    outb(), outw(), outl(), outsb(), outsw(), outsl(): 하드웨어에 데이터를 써넣는다.


16. 다음과 같은 명령을 이용하여 디바이스 드라이버를 커널에 삽입한다.
 $ insmod driver.o
 여기서 driver.o는 테스트로 작성된 디바이스 드라이버 파일명이다.
 위와 같이 콘솔에서 insmod driver.o 를 실행 시키면 다음과 같은 시스템 콜이 수행되어 드라이버를 커널에 삽입한다.
 1. sys_create_module()을 사용하여 디바이스 드라이버를 적재하기 위한 메모리를 할당한다.
 2. sys_get_kernel_syms()를 이용하여 driver.o 안에 있는 심볼을 커널에 등록한다. 
    (커널에 등록했기때문에 커널 모드로써 다른영역접근가능한듯)
 3. 마지막으로 sys_init_module() 을 사용하여 driver.o를 메모리에 적재한다. 
 이 과정에서 driver.o 안에 있는 init_module()이 실행되고 그 안에 있는 커널 함수인 register_chrdev() 가 수행되어 
 디바이스 드라이버 이름과 메이저 번호와 file_operations 구조체를 커널 변수인 chrdevs에 등록한다.
 (file_operations 구조체는 open release 등의 함수를 dev 드라이버 함수와 매핑한 구조체이다 -> 이걸 등록하는게 주 목적임)
 위와 같이 디바이스 드라이버를 커널에 삽입했으면 다음 해야 하는 일은 드라이버에 대응하는 특수 장치 파일(노드)을 만드는 일이다.

 다음은 콘솔에서 특수 장치 파일을 만드는 명령이다.
 $ mknod /dev/device c 주번호 부번호
 위의 명령에 의해 커널에서 수행 되는 일은 다음과 같다. 
 mknod 명령은 커널의 sys_mknod()를 호출하고 이 함수는 다음과 같은 일을 수행한다.
 1. 먼저 /(root) 에서 시작해서 dev 디렉토리까지의 경로를 찾아 새로운 dentry를 하나 만들고 루트에 연결한다.
 2. inode 하나를 만들고 dentry의 d_inode에 연결한다.
 3. inode의 i_mode 와 i_rdev에 S_IFCHR 과 (주번호 << 8 | 부번호)을 기록한다. (inode의 역할)
 4. inode의 i_fop에 def_chr_fops의 주소값을 기록하여 이를 통해 open 메소드에 chrdev_open()이 연결되도록 한다. (open함수 매핑)

 즉 insmod에서 디바이스 이름과 MAJOR을 커널에 등록하고 mknod를 통해 정해진 major로 dev쪽에 노드(파일)를 만들어야한다고한다.
  -> 파일을 만드는 이유는 우리가 파일로써 관리할것이기 때문이다.

17. 알아채는 방식은 주변 디바이스와 일대일로 연결(링크)되어 
     디바이스 파일을 User Application이 open() 함수를 이용하여 열게(Open) 되면,
     open() 함수를 서비스해주기 위해 리눅스 커널이 해당 파일로 접근하게 되고, 이 파일이 디바이스 파일임을 알게 되면
     해당 디바이스를 제어하겠다고 자신(Kernel)에게 등록한 Device Driver들을 검색하게 된다. 
     만약 해당 Device Driver를 찾지 못하게 되면, 
     서비스를 요청한 User Application에 오류 메세지를 보내준 후 프로그램을 종료시키고, 
     해당 Device Driver를 찾게 되면 실행시켜 연동되도록 서비스해준다. (커널이 major번호를 리턴해줌 앞으로 찾을필요 없게)

  -> 즉 read(dev,&data,4)시에 커널에게 major번호를 주는것이기에 커널이 major번호를 토대로 디바이스 read함수를 실행시켜줌
  -> read,write같은 저수준 입출력함수는 커널에서 스트림열어주고 관리해주기 때문에 커널이 알아차릴 수 있는것이다.

18. ssize_t xxx_write (struct file *flip, char *buff, size_t count, loff_t *offp)
  -> ssize는 4byte unsigned int이다. 이걸 안바꾸는 이유는 나중에 컴터가 발전해서 int가 4byte가 아니게 될 때 구별하기 위함
  -> loff_t f_ops        f_pos 필드 변수에는 현재의 읽기/쓰기 위치를 저장
  -> struct file *flip   읽기와 쓰기에 전달되는 flip은 디바이스 파일이 어떤 형식으로 열렸는가에 대한 정보를 저장
  -> count는 하드웨어에 보내려는 데이터 개수 or 읽어오려는 데이터 개수 (read에서)

19, - GPIO는 프로세서에서 노출되는 하나의 연결 단자를 입력이나 출력으로 고정시키지 않고 
선택적으로 사용할 수 있게 융통성을 높인 범용 입출력 단자
- gpio_requestGPIO_LED3_TEST, "TEST_LED3") 
  할당 및 검사 (다른 드라이버와 중복사용을 피하고자 할 때 이용한다 + GPIO 핸들링 권한 얻는용도) 
- gpio_free(GPIO_LED3_TEST) 제거
- gpio_direction_input(GPIO_LED3_TEST) 입력 지정
- giop_direction_output(GPIO_LED3_TEST, 0) 출력 지정 기본 출력상태 low
- gpio_get_value(GPIO_LED3_TEST) 값 읽기
- gpio_set_value(GPIO_LED3_TEST, LED_ON) 값 쓰기
- gpio_export() 사용자 공간에서 접근할 수 있도록  sysfs에 노출
- gpio_to_irq() gpio 번호를 irq번호로 변환
- s3c_gpio_setpull(GPIO_LED3_TEST, S3C_GPIO_PULL_NONE); //풀업 설정용
-set_irq_type( irq_nr, irq_type ); -> 인터럽트 활성화 참고하기 irq 검색해보기

#define GPIO_LED3_TEST S5PV210_GPH0(4) /*LED３GPIO 포트 할당*/
#define GPIO_LED4_TEST S5PV210_GPH0(5) /*LED４GPIO 포트 할당*/
#define GPIO_LED5_TEST S5PV210_GPH0(6) /*LED５GPIO 포트 할당*/

 -> https://wiki.koansoftware.com/index.php/IMX6_definitive_GPIO_guide
 -> Imx6dq GPIO 주소 찾는법 + 핀이름 매핑

 -> gpio_free를 수행하는 순간부터 gpio_set_value 함수가 안된다고한다.

------------------------------------------------------------------------------------------------------------------
질문 - 드라이버 init이후에도 계속 이 모듈은 메모리에 있는것인가? -> 가상주소가 왜 안없어지는지
      - 다른 프로세스 메모리에 접근하려면 커널모드가 돼야 한다는데 이게 맞는건지? -> 이건 맞는말이긴하다 직접접근은 아니더라도
        또한 저게 맞다면 jni c언어에서는 어떻게 적용되고 있는것인가? -> 자바, c언어 둘다 사용자 메모리라 가능한듯하다. (유저영역이기때문)
        (커널모드라도 함수를 써서 메모리 복사해야하는데 어떻게 가능한가)
        (애초에 커널모드 아니라도 함수로 접근이 가능한가?)
    - export함수 찾아보기
------------------------------------------------------------------------------------------------------------------

20. file:///C:/Users/jmink/Downloads/LM2001020317,+LM2001020318_%EB%94%94%EB%B0%94%EC%9D%B4%EC%8A%A4+%EB%93%9C%EB%9D%BC%EC%9D%B4%EB%B2%84+%EB%B6%84%EC%84%9D+%EC%84%A4%EA%B3%84.pdf
     -> 67페이지 정도부터 사용자, 커널 메모리접근 설명 잘 나와있음
     프로세스가 사용자 모드에서 커널 모드로 진입하기 위해서는
     시스템 콜에 관련된 함수를 호출해야 한다. 시스템 콜에 관련된 대표적인 함수는 저수준
     파일 입출력 함수들이다. 특히, 디바이스 파일에 저수준 파일 입출력 함수를 사용한다면
     (디바이스드라이버는 애초에 커널 메모리에 등록했었음)
     시스템 콜을 사용하는 것으로 보아도 무방하다.

     이 시스템 콜은 소프트웨어 인터럽트를
     이용해 구현한다. 소프트웨어 인터럽트가 발생하면 해당 프로세스는 커널 모드로 진입한다. 
     이렇게 프로세스는 사용자 모드와 커널 모드로 나뉜다. 

     사용자 메모리 공간과 커널 메모리 공간 사이의 직접적인 접근은 불가능하다

     - 사용자 -> 커널 접근은 mmap()함수만 가능 (/dev/mem)에 있는것.
         but 커널 메모리 공간을 사용자 메모리 공간으로 매핑시키는 것이라 제한적
        즉 커널함수 쓰려면 커널모드여야하는것같다.
        즉 디바이스 드라이버는 커널모드에서 i/o메모리 접근을 위해 자체 커널 함수인 ioremap을 통해 바로 가지만
            mmap은 사용자 영역에서 /dev/mem을 열어 그 mem내부에있는 함수를 이용해 매핑하는 것이다
            따라서 mmap은 하나의 과정이 더 필요한것같다.
     
    -> 리눅스는 모든게 파일로이루어져있기에 파일에 가상 메모리를 할당해 레지스터의 해당 메모리 주소로 가서 변경해야한다.
         즉 커널의 접속이 필요하다는 뜻이다. (아트메가의 경우 커널이 없기에 레지스터 주솟값에 바로 입력해주면됐었음)

     - 커널 -> 사용자 접근은 커널에서 제공하는 특별한 함수를 이용해 사용자 메모리의 데이터를 커널 메모리로 옮겨서 사용

21. https://jhnyang.tistory.com/190
  -> 커널모드 vs 유저모드
  -> I/O장치를 보호하기위해 CPU에 두가지 모드가 있다고한다 ★★★★★★★★★★★★★★
  -> ex) 컴퓨터 하드디스크에있는 내용을 싹 지워버리는 프로그램같은건 위험하기때문.
  -> 따라서 일반적인 앱 프로그램들은 I/O장치에 접근할수없고 운영체제를 통해서만 접근가능하게한것.
  -> 따라서 디스크 내용을 읽을 땐 커널이 중간 전달자가 된다.
  -> 프로그램이 어떤 자료가 필요해 ex- 파일 -> 이러면 프로그램이 직접 access하는게 아닌 운영체제에게 요청을 한다.
      (이걸 시스템콜이라 부른다)
  -> 커널모드는 운영체제 코드나 디바이스 드라이버 같은 커널 모드 코드를 실행한다 (즉 디바이스 드라이버를 커널에 등록시키는게 중요)

22. 라파 gpio파일에 스위치를 인터럽트로 제어하는법 나옴

23. IIO - Linux Industrial I/O subsystem - void_inside - 티스토리
  -> IIO가 adc를 위한것이라고한다.
---------------------------------------------------------------------------
컴파일 환경
27. sudo apt-get install lib32z1
  -> 64bit OS 우분투에서 32bit arm 컴파일러를 사용하기위해서는 (도구체인 사용을 위해) 이걸 설치 필요
  -> 64bit의 호스트를 설치한 경우 CD에 포함된 툴체인이나 기타 바이너리들은 32bit용으로 배포가
      되어 있으므로 사용하지 못한다. 따라서 64bit 환경에서 32bit 라이브러리 및 바이너리를 사용할
      수 있도록 호환해주는 라이브러리를 별도로 설치해주도록 한다.

28. flex와 bison 프로그램이 설치되어있지 않아 빌드가 실패했습니다.
  -> apt-get으로 설치해주기

  -> 커널소스 찾아야하는 이유가 그거같다 (커널 소스 빌드쪽에서 어떤 보드에 타겟할건지 물어보는게 너무많다)
  -> imx6q 커널소스면 이런거 안물어보고 바로 빌드 될듯
  -> /lib/modules/5.13.0-1029-aws/build
  -> /home/ubuntu/temp/work/achroimx6q/linux-2.6.16/kernel
  -> make에서 -C option은 뒤의 parameter로 directory를 변경하라는 의미
  -> KERNEL_PATH: 보드용 (이미 컴파일된) 커널이 포함된 디렉토리. 즉 imx6q커널을 컴파일 시켜야한다?
  -> kernel 소스 다운받은 후 make uImage로 컴파일 시켜야 가능하다. (make achroimx_defconfig의 경후 환경설정임)

  -> imx6q의 경우 https://github.com/embeddedTS/linux-3.0.35-imx6
  -> 리눅스 3.0.35버전을 사용한다고한다.
  -> Module.symvers가 있는 위치를 KDIR로 잡아야함
  -> ~/temp/work/achroimx6q/linux-3.0.35-imx6에 있음 (원래는 kernel에 있어야하는데 makefile이 애초에 전 파일에 있었음)
  -> 즉 드라이버 모듈을 만들어서 보드 커널과 드라이버 모듈(.ko파일)을 링크해서 사용하는게 목적이다.
     (커널 업데이트도 커널 소스를 make로 컴파일해서 커널 모듈을 만든다음 커널쪽에 파일들을 옮겨주면 되는것이다)

  -> ★★ 커널의 모듈은 요청 시 커널에 로드 및 언로드할 수 있는 코드 조각이다.
      시스템을 재부팅할 필요 없이 커널의 기능을 확장한다.
      예를 들어, 한 가지 유형의 모듈은 커널이 시스템에 연결된 하드웨어에 액세스할 수 있도록 하는 디바이스 드라이버이다.
      모듈로 관리함으로써 커널 기능추가마다 커널 전체를 컴파일해야하는 불상사를 방지한다.

  -> sudo apt-get install linux-headers-generic
  -> (linux/init.h)이런 리눅스 헤더 없을 때 이거 필수 설치
  -> 그냥 linux 이거 안되는 이유는 저 파일은 모듈만드는 용도라 크로스컴파일러랑 좀 다르다.
  -> linux/init.h는 리눅스 커널 모듈 프로그래밍에 쓰인다. 따라서 일반적인 크로스컴파일에서는 쓰이는게 아닌듯.

---------------------------------------------------------------------------
 질문
  -> read시 and연산 하는 이유?
  -> 모듈 만들때는 크로스컴파일러가 안필요한가? 무조건 필요하긴할듯 어쨋든 그쪽보드 모듈에서 아는 언어로 실행해야하니까?
       -> 근데 왜 크로스컴파일러가 linux/init.h를 인식못하나 (모듈 컴파일시에만 인식하나?)
  -> 모듈만들때 크로스컴파일이 이용되는지 물어보기 (만약 필요하다면 명시를 안해주는데 어떻게 사용되는지?)
---------------------------------------------------------------------------
해결
  -> make파일 질문하기
  -> 커널 소스의 역할? (우분투 커널소스 넣어도 되는지?) -> 모듈은 커널 버전영향을 많이 받음으로 비슷한 환경 설치해주기위함.
  -> .c파일 헤더파일 없다면서 자꾸 에러남 (make modules하면 에러안남)
  -> 생성된 ko파일을 왜 지우는지? -> make clean일 때만 지움
  -> 왜 ko파일 생성 안되는지.. -> pwd가 잘못써져있었음
  -> make 하면 바로 되는 이유? -> target이 driver:라서 driver:명령문이 자동 먼저실행됨
  -> shell pwd와 pwd의 차이? -> makefile에서 쉘명령어 방법이 $(shell pwd)밖에 없음
  -> test파일의 이유? -> c언어로 그냥 직접 해보려고
---------------------------------------------------------------------------
29. makefile 변수
  -> T = A
      W = $(T)
      T = B
  -> W에는 B값이 들어간다 왜? =은 최종적으로 실행하는 단계(run)에서 마지막으로 할당된 변수 가져옴
      즉 T= B가 실행되고 W = $(T)가 실행된다
  -> 따라서 W := $(T)를 해줌으로써 실제 변수를 작성한 시점 W = $(T)를 쓴 시점에서 T=A인 값이 들어간다.
  
  -> makefile에선 변수 접근할 때 무조건 $()를 해줘야한다.

30. makefile 쉘 명령어 입력 망법
  -> 변수에는 $(shell pwd)처럼 해주고
  -> target:
   echo 이것은 test
  -> 실행되는 타겟 밑에 쉘 명령어를 써줘도 된다.
--------------------------------------------------------------------------------
31. 초음파 or 모션인식으로 공격 or 필살기
  -> 서버 만들어서 1:1 가능하게?
  -> 모션인식 인터럽트 -> 디바이스 오픈시켜두고 close는 나중에하면되려나
  -> 아니라면 모듈 없앨 떄 동작하므로 모듈이 올라가있다면 계속 동작하는것인가?
  -> 모션인식의 활용을 생각한다면 괜찮을듯.

  -> 데이터 주소값을 고정시켜두면 되려나 모르겠네

32. adc핀을 찾을수 없었다. (있다긴 하지만 base보드에서 찾을수가없음)
